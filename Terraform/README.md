# Graph Least Privilege Manager App Registration and Service Principal

The following [Terraform](https://developer.hashicorp.com/terraform/intro) scripts are designed to create a Microsot Entra (formerAzure Active Directory (AAD)) application and its associated service principal.

The app registration is configured with a single `scope` (allowing user- and service principal to acquire OAuth JWT access tokens), and multiple [roles](../README.md#groups) that will be utilised to to restrict access to endpoints. \
This will facilitate allowing principals to manage the lifecycle of groups they've created.

The service principal is configured with a "elevated privilege": `Group.ReadWrite.All`. \
This enables the service principal (representing the app registrations identity) to create, read, update and delete groups on behalf of principals who have been pre-authorized through [role](../README.md#groups) assignment.

**NB!**: After running these scripts an Azure AD `Global Administrator` must grant `admin consent` to the [requested privileges](#outputs) prior to you attempting to run the [application](../README.md#running-it-locally).

## Terraform

### Variable Inputs

The script expects the following variables:

- `var.application_name`: The display name of the Azure AD app registration and service principal.
- `var.identifier_uri`: (Optional) The identifier URI of the Azure AD app registration. 
  - If not provided, a default one will be generated using `var.application_name`: `api:${var.application_name}`.
- `var.redirect_uris`: The pre-approved URIs Azure AD will send security tokens back after successfull authentication.
  - Can be localhost (for development)
  - Must be https when the application when hosted somewhere reachable for the organization
- `var.roles`: The list of "scopes" that will be created as application roles. They're used to restrict access to API routes.
- `var.tags`: A JSON encoded string of key-value pairs to assign as notes to the application and its associated service principal.
- `var.additional_owners`: A list of additional owners for the application and its associated service principal.
  - The applying identity will be added as owner by default

### Resources Generated

The following resources are generated by this script:

1. `azuread_application.this`: This resource represents the Azure AD application. Its configurations include features (such as visibility and SSO settings), API and web configurations, app roles, Microsoft Graph resource access, and more. The application's resource access permissions include roles for managing groups, user principals, and application principals.

2. `azuread_service_principal.this`: This creates a service principal associated with the above Azure AD application. It uses the same application ID and also includes the settings for app role assignment requirements and single sign-on. This is the identity whom is granted the privileges to manipulate the Graph API on behalf of authorized principals.

3. `azuread_application_password.this`: The client secret that the application will use to authenticate against Microsoft Graph when performing API actions on behalf of authorized principals. **NB!: Should be set up with rotation, in accordance with organization policies!**


### Downstream usage

By using the "service principal display name" you will be able to further automate group assignment through, for instance, GitHub Action.  

Use the following terraform scripts (assuming the default variable display name) to access the available roles and scopes defined within the application:

```s
###########
### Requires Application.Read.All permission or Application.ReadWrite.OwnedBy (assuming the invoking principal 
### is a centrally managed service user utilised for automation)

### Access the existing service principal data sources ###
data "azuread_service_principal" "this" {
  display_name = "graph-api-least-privilege-manager"
}

### Output application roles and ids ###
output "application_roles" {
  value = data.azuread_service_principal.this.app_role_ids
}
# application_roles  = {
#     "Group.Read"                     = "d6b5014e-3dc3-c01e-f4b0-0fb68451fd79"
#     "Group.ReadWrite.OwnedBy"        = "5c0b0180-8e2b-2fe8-a057-8ef088094f26"
#     "Group.ReadWriteControl.OwnedBy" = "8cbb9e1b-57e4-cf6f-569f-63fd8fa8defc"
#     "Group.ReadWriteMember.OwnedBy"  = "0ffb54dd-eb02-b483-d1fb-a9030d445d7d"
#     "Group.ReadWriteOwner.OwnedBy"   = "34cb5fe3-391e-b4b8-1420-a97edecc65f7"
# }

### Output application scopes and ids ###
output "application_scopes" {
  value = data.azuread_service_principal.this.oauth2_permission_scope_ids
}
# application_scopes = {
#     "OAuthToken" = "a8a787de-b305-ccc7-f594-d7f8b17255fb"
# }
```

Then you can utilise that information in the following manner to assign `user` or `service principals` to application roles:

```s
data "azuread_user" "this" {
  user_principal_name = "some-user@your-org.com"
}

resource "azuread_app_role_assignment" "read" {
  resource_object_id  = data.azuread_service_principal.this.object_id
  app_role_id         = data.azuread_service_principal.this.app_role_ids["Group.Read"]
  principal_object_id = data.azuread_user.this.object_id
}
```

### Service principal usage

In order to let service users acquire an access token for this application (they always claim the `<indentifier-uri>/.default` scope), you must pre-autorize them to access an application's APIs without requiring user consent. You can do that with the following terraform resource:

```s
###########
### Requires either Application.ReadWrite.OwnedBy for `data.azuread_service_principal.this.application_id`
### or Application.ReadWrite.All (which really is not recommended since the scope of this solution is "least privilege")

resource "azuread_application" "example" {
  display_name     = "example"
}

resource "azuread_application_pre_authorized" "client_authorization" {
  application_object_id = data.azuread_service_principal.this.application_id
  authorized_app_id     = azuread_application.example.application_id
  permission_ids = [
    data.azuread_service_principal.this.oauth2_permission_scope_ids["OAuthToken"]
  ]
}
```

### Outputs

The result of running this script is a configured Azure AD application, its associated service principal with the following [Microsoft Graph permissions](https://learn.microsoft.com/en-us/graph/permissions-reference):

- [Group.ReadWrite.All](https://learn.microsoft.com/en-us/graph/permissions-reference#application-permissions-38)
- [User.Read.All](https://learn.microsoft.com/en-us/graph/permissions-reference#application-permissions-93)
- [Application.Read.All]()

### Automate Admin Consent?

Beware that I have not tried any of these terraform "hacks" myself, but the fact that they must be run in the context of an authenticated principal with the `Global Administrator` role make this automation in practice out of reach for most people (outside of their own test tenant).

- [az ad app permission](https://solideogloria.tech/terraform/grant-admin-consent-for-an-azure-ad-application-with-terraform/)
- [az rest](https://devcoops.com/terraform-grant-azure-ad-admin-consent/?utm_content=cmp-true)
